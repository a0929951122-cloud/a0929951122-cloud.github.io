<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 3D 魔法世界</title>

    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Marcellus&display=swap" rel="stylesheet">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #020209;
            font-family: 'Marcellus', serif;
            color: #fff;
        }

        /* RPG 風標題 */
        .hero {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
        }

        .hero h1 {
            font-family: 'Cinzel', serif;
            font-size: 70px;
            letter-spacing: 4px;
            text-shadow: 0 0 20px #8ecaff, 0 0 40px #3fb3ff;
        }

        .hero p {
            font-size: 22px;
            margin-top: 10px;
            opacity: 0.85;
        }

        /* RPG HUD */
        .hud {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            text-align: center;
            z-index: 10;
        }

        .bar-container {
            width: 100%;
            height: 20px;
            margin-top: 10px;
            border: 2px solid #fff5;
            border-radius: 5px;
            overflow: hidden;
            background: #111;
        }

        .hp {
            background: linear-gradient(90deg, #ff3d3d, #ff8b8b);
            height: 100%;
        }

        .mp {
            background: linear-gradient(90deg, #3dacff, #8cd2ff);
            height: 100%;
        }

        .exp {
            background: linear-gradient(90deg, #ffc63d, #ffe58b);
            height: 100%;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

    <!-- RPG 主標題 -->
    <div class="hero">
        <h1>ARCANE REALM</h1>
        <p>喚醒沉睡的魔力 · 點擊施放魔法</p>
    </div>

    <!-- RPG HUD -->
    <div class="hud">
        <div class="bar-container"><div class="hp" style="width: 85%;"></div></div>
        <div class="bar-container"><div class="mp" style="width: 60%;"></div></div>
        <div class="bar-container"><div class="exp" style="width: 40%;"></div></div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ====== 基本設定 ======
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ====== 魔法陣（圓形 Wireframe） ======
        const circleGeo = new THREE.RingGeometry(2.5, 3, 60);
        const circleMat = new THREE.MeshBasicMaterial({
            color: 0x3db2ff,
            wireframe: true,
            transparent: true,
            opacity: 0.6
        });
        const magicCircle = new THREE.Mesh(circleGeo, circleMat);
        magicCircle.rotation.x = -Math.PI / 2;
        scene.add(magicCircle);

        // ====== 浮動寶珠 ======
        const orbGeo = new THREE.SphereGeometry(0.7, 32, 32);
        const orbMat = new THREE.MeshStandardMaterial({
            color: 0x8cc8ff,
            emissive: 0x2a74ff,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.95
        });
        const orb = new THREE.Mesh(orbGeo, orbMat);
        orb.position.y = 1.3;
        scene.add(orb);

        // ====== 光源 ======
        const light = new THREE.PointLight(0x88ccff, 2, 20);
        light.position.set(0, 3, 3);
        scene.add(light);

        camera.position.z = 6;

        // ====== 滑鼠控制相機 ======
        let mouseX = 0, mouseY = 0;

        document.addEventListener("mousemove", (e) => {
            mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
            mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
        });

        // ====== 魔法粒子（施法特效） ======
        const particles = [];
        const pGeo = new THREE.SphereGeometry(0.1);

        function castMagic() {
            const p = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({
                color: 0x7fc1ff,
                transparent: true,
                opacity: 1
            }));

            p.position.set(0, 1.3, 0);
            p.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.25,
                (Math.random() - 0.3) * 0.6,
                (Math.random() - 0.5) * 0.25
            );

            scene.add(p);
            particles.push(p);
        }

        document.addEventListener("click", () => {
            for (let i = 0; i < 30; i++) castMagic();
        });

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y += 0.005;
                p.material.opacity -= 0.015;

                if (p.material.opacity <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // ====== 動畫 ======
        let t = 0;

        function animate() {
            requestAnimationFrame(animate);

            // 魔法陣旋轉
            magicCircle.rotation.z += 0.002;

            // 漂浮寶珠上下跳動
            orb.position.y = 1.3 + Math.sin(t * 2) * 0.2;
            t += 0.01;

            // RPG 視角：相機微漂移
            camera.position.x += (mouseX * 0.8 - camera.position.x) * 0.03;
            camera.position.y += (-mouseY * 0.6 - camera.position.y) * 0.03;
            camera.lookAt(scene.position);

            updateParticles();

            renderer.render(scene, camera);
        }

        animate();

        // 視窗大小重設
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
